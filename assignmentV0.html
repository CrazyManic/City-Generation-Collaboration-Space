<html>
<head>
    <title>GroupAssessment</title>
</head>
<style>

    body {
        margin: 0;
    }

    canvas {
        width: 100%;
        height: 100%;
    }
</style>
<body>
    <!--include the three.js library-->
    <script src="js/three.js"></script>
    <script src="js/Block.js"></script>
    <script src="js/LinkedList.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/PLYLoader.js"></script>
    <script src="js/Buildings.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <style>

        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
        }
    </style>
    <div id="info">
        <p>This is a threeJS Test<br>
    </div>
    <script>
        var scene = new THREE.Scene();//create the scene
        var renderer = new THREE.WebGLRenderer();//create the webgl renderer
        renderer.setSize(window.innerWidth, window.innerHeight);
        //add the renderer to the current document
        document.body.appendChild(renderer.domElement);
        var ratio = window.innerWidth / window.innerHeight;

        // Background color should be turned off but makes things very visible
        scene.background = new THREE.Color(new THREE.Color(0.3, 0.6, 0.0, 1.0));
        //create the perspective camera
        var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
        // Camera is set to these for testing the generation of blocks. 
        // Should be closer to (0, -0.2, 1) in the game
        var cameraDirection = new THREE.Vector3(0, -1, 0.1);
        camera.lookAt(cameraDirection.x, cameraDirection.y, cameraDirection.z);// and the direction
        // for real game set it more like (0, 5, -15)
        var cameraPosition = new THREE.Vector3(0, 150, -25);
        camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);//set the camera position
        var cameralight = new THREE.PointLight( new THREE.Color(1,1,1), 0.5 );
        camera.add( cameralight );
        scene.add(camera);

        var boxMat = new THREE.MeshLambertMaterial();
        boxMat.color = new THREE.Color(0.6, 0.3, 0.0, 1.0);
        var box = new THREE.Mesh(new THREE.BoxGeometry(1,1,2), boxMat);
        box.position.set(1,0,1);
        scene.add(box);
        
        // Set game constants
        var loadRadius = gridSize * 6.5;
        console.log('Blocks grid size: ' + gridSize); 

        // Set game variables
        var playerPos = new THREE.Vector3(0, 0, 0);
        var playerLook = new THREE.Vector3(0, 0, 0);
        var velo = new THREE.Vector3(0,0,0); //velocity
        var accel = new THREE.Vector3(0,0,0);//acceleration

        // Generation amounts
        var cur_urbanness = 50;

        // movement variables
        var turnRight = false;
        var turnLeft = false;
        var goDirForward = false;
        var goDirBackward = false;


        // Not sure how to use these for the camera code
        // var flatOffset = new THREE.Vector3(0, 0, 0);
        // var vertOffset = new THREE.Vector3(0, 0, 0);



        // // testing linked list
        // var list = new LinkedList();
        // list.addNodeAtHead('start');
        // console.log(list.size);
        // console.log(list.getNodeAtIndex(0));
        // list.addNodeAtTail('middle');
        // list.addNodeAtTail('end');
        // console.log(list.head);
        // console.log(list.getNodeAtIndex(5));
        // console.log(list.head.next.value);
        // list.removeNodeAt(1);
        // console.log(list.getNodeAtIndex(1));
        // // end test linked list

        // Initialise blocks
        let blocks = new LinkedList();
        let intRad = (loadRadius / gridSize);
        for (y = intRad; y >= -intRad; y--){
            for (x = intRad; x >= -intRad; x--){
                if ((x*x + y*y) <= intRad * intRad){
                    //console.log('(' + x + ',' + y+'): ('+ (x*gridSize) + ',' + (y*gridSize)+')');
                    var newBlock = new Block(new THREE.Vector3(x * gridSize, 0.0, y*gridSize), scene);
                    newBlock.position = new THREE.Vector3(x * gridSize, 0.0, y*gridSize);
                    newBlock.floor.position = new THREE.Vector3(x * gridSize, 0.0, y*gridSize);
                    blocks.addNodeAtTail(newBlock);
                    //console.log("floor.pos: " + newBlock.floor.position + " pos: " + newBlock.position);
                }
                //else
                //    console.log('NOT (' + x + ',' + y+')');
            }
        }
        //console.log(blocks.head.value.floor.position);
        //console.log(blocks.head.next.value.floor.position);
        //console.log(blocks.head.next.next.value.floor.position);
        //box.position.set(blocks.head.next.next.value.floor.position);
        box.position.set(0,120,-10);
        
        //camera.lookAt(blocks.head.next.next.value.floor.position);
        // for (rows=intRad; rows >= -intRad; rows--){
        //     //var theta = Math.asin(rows/intRad);
        //     var theta = Math.ceil(Math.acos(rows / intRad));
        //     var genWidth = Math.ceil(intRad/2 * Math.acos(theta));
        //     console.log("New row: " + rows + ", with width: " + genWidth + "\tTheta: " + theta + "\tacos: " + Math.acos(theta));
        //     for (cols = genWidth; cols >= -genWidth; cols--){
        //         //console.log("Adding block at: (" + cols + ", " + rows + ")");
        //         //blocks.addNodeAtTail(new Block(new THREE.Vector3(rows * gridSize, cols*gridSize, 0.0)));
        //     }
        // }

        const clock = new THREE.Clock();
        //var delta = clock.getDelta(); // use this as necessary, just not in this scope.

        function ConvertToGrid(inVec) {
            return new THREE.Vector3(Math.round(inVec.x / gridSize) * gridSize, Math.round(inVec.y / gridSize) * gridSize, Math.round(inVec.z / gridSize) * gridSize, );
        }

        // Gameplay functions
        function UpdatePlayerPosition() {
            var delta = clock.getDelta();
            // Make sure acceleration is up to date. 
            // Apply friction, i.e acc += velo * -0.05
            //velo.add(accel.multiplyScalar(delta); // should be correct
            //playerPos.add(velo.multiplyScalar(delta));

            // Delete blocks that are too far 
            for (i = 0; i < blocks.size; i++) {
                //console.log("Iterating pos x: " + blocks.getNodeAtIndex(i).position.x);
                if (blocks.getNodeAtIndex(i).position.distanceTo(ConvertToGrid(playerPos)) >= loadRadius) { // Destroy this block
                    blocks.getNodeAtIndex(i).destroy();
                    blocks.removeNodeAt(i);
                    i--;
                }
            }
            // Generate new blocks
            for (y = intRad; y >= -intRad; y--){
                for (x = intRad; x >= -intRad; x--){
                    if ((x*x + y*y) <= intRad * intRad){
                        var posUsed = false;
                        var thisPos = new THREE.Vector3(x * gridSize, 0.0, y*gridSize).add(ConvertToGrid(playerPos));
                        for (i=0; i < blocks.size; i++){
                            if (blocks.getNodeAtIndex(i).position.equals(thisPos)){
                                posUsed = true;
                                //console.log("Block already occupied: ("+thisPos.x+','+thisPos.y+')');
                            }
                        }
                        if (!posUsed){
                            //console.log('(' + x + ',' + y+'): ('+ (x*gridSize) + ',' + (y*gridSize)+')');
                            var newBlock = new Block(thisPos, scene);
                            newBlock.position = thisPos;
                            newBlock.floor.position = thisPos;
                            blocks.addNodeAtTail(newBlock);
                            //console.log("Adding new block at ("+thisPos.x+','+thisPos.y+')');
                            //console.log("floor.pos: " + newBlock.floor.position + " pos: " + newBlock.position);
                        }
                    }
                    //else
                    //    console.log('NOT (' + x + ',' + y+')');
                }
            }
            //console.log(blocks.size);
        }
        //blocks.getNodeAtIndex(2).destroy();
        box.position.z = 50;


        // generating new buildings
        //var bldg_1 = new Building(100 ,new THREE.Vector3(0, 0, 0), new THREE.Color(1,0,0)); // Red, very urban
        //var bldg_2 = new Building(0, new THREE.Vector3(30, 0, 0), new THREE.Color(0,1,0));  // Green, not at all urban
        //var bldg_3 = new Building(30, new THREE.Vector3(60, 0, 0), new THREE.Color(0,0,1)); // Blue, sometimes highrise, usually not

        var turnRight = false;
        var turnLeft = false;
        var goDirForward = false;
        var goDirBackward = false;
        //blocks.getNodeAtIndex(2).destroy();
        box.position.z = 50;
        // Need to figure out which number we need for offset
        var cameraOffset = -15;
        var rotationSpeed = 5;
        //yeah we need to change movespeed to acceleration or something
        var moveSpeed = 40;
        var rotationAngle = 0;

        var MyUpdateLoop = function () {
            // code

            //turning code (This is just a code to get started when we do rotations)
            var delta = clock.getDelta();

            if (turnRight == true) 
            {
                rotationAngle -= rotationSpeed * delta;
                playerLook.x = Math.sin(rotationAngle);
                playerLook.z = Math.cos(rotationAngle);
                playerLook.normalize();
            }
            if (turnLeft == true)
            {
                rotationAngle += rotationSpeed * delta;
                playerLook.x = Math.sin(rotationAngle);
                playerLook.z = Math.cos(rotationAngle);
                playerLook.normalize(); 
            }
            if (goDirForward == true)
            {
                playerPos.x += playerLook.x*moveSpeed*delta;
                playerPos.z += playerLook.z*moveSpeed*delta;
            } 
            if (goDirBackward == true)
            {
                playerPos.x -= playerLook.x*moveSpeed*delta;
                playerPos.z -= playerLook.z*moveSpeed*delta;
            }

            //box.position.set(blocks.getNodeAtIndex(incrementor).position.x,blocks.getNodeAtIndex(incrementor).position.y,blocks.getNodeAtIndex(incrementor).position.z);
            //console.log(blocks.getNodeAtIndex(incrementor).floor.position);
            //incrementor = (incrementor + 1) % blocks.size;

            box.position.z = playerPos.z;
            console.log(rotationAngle * (180/Math.PI));
            
            box.rotation.y = playerLook.z;
            box.rotation.y = playerLook.x;


            box.position.x = playerPos.x;

            cameraPosition.z = playerPos.z - 2.5;
            
            cameraPosition.x = playerPos.x;


            //setting camera position to the player

            // not sure what to do about the camera angle 
            // cameraPosition = playerPos - flatOffset * playerLook + vertOffset; 
            
            camera.position.set(cameraPosition.x,cameraPosition.y, cameraPosition.z);
            camera.updateProjectionMatrix();
            UpdatePlayerPosition();

            renderer.render(scene, camera);
            requestAnimationFrame(MyUpdateLoop);
        }
        requestAnimationFrame(MyUpdateLoop);

        //this function is called when the window is resized
        var MyResize = function () {
            //get the new sizes
            var width = window.innerWidth;
            var height = window.innerHeight;
            //then update the renderer
            renderer.setSize(width, height);
            //and update the aspect ratio of the camera
            camera.aspect = width / height;

            //update the projection matrix given the new values
            camera.updateProjectionMatrix();

            //and finally render the scene again
            renderer.render(scene, camera);
        };

        // Input
        var onKeyDown = function (event) {

            switch (event.keyCode) {
                case 38: // up
                case 87: // w
                    // just to test movement.
                    goDirForward = true;
                    break;

                case 37: // left
                case 65: // a
                    turnLeft = true;
                    break;

                case 40: // down
                case 83: // s
                    goDirBackward = true;
                    cameraSpeed = 4; 
                    break;

                case 39: // right
                case 68: // d
                    turnRight = true;
                    break;
            }

        };

        var onKeyUp = function (event) {

            switch (event.keyCode) {
                case 38: // up
                case 87: // w
                    goDirForward = false;
                    break;

                case 37: // left
                case 65: // a
                    turnLeft = false;                    
                    break;

                case 40: // down
                case 83: // s
                    goDirBackward = false; 
                    cameraSpeed = 10; 
                    break;

                case 39: // right
                case 68: // d
                    turnRight = false;                    
                    break;
            }
        };

        //link the resize of the window to the update of the camera
        window.addEventListener('resize', MyResize);
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        function buildGui()
        {
            gui = new dat.GUI();
            
            //this is just a placeholder 
            var params = {PlayerPositionZ: playerPos.z,
                PlayerPositionX: playerPos.x,
                PlayerPositionY: playerPos.y}

            gui.add( params, 'PlayerPositionZ', 0, 150 ).onChange( function ( val ) {
                playerPos.z = val;
            });

            gui.add( params, 'PlayerPositionX', 0, 150 ).onChange( function ( val ) {
                playerPos.x = val;
            });
            //playerholder ends here!

            gui.open();

        }

        buildGui();

        function onWindowResize() 
        {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener( 'resize', onWindowResize, false );


    </script>
</body>
</html>


